# modularize the KOB decomposition so that standard errors can be easily applied

# First, we cache group-level means to merge with the regression results
# To do this, we need to specify the regression equation and then make it in such a way
# that it can be easily merged

# ----- STEP 0: Configuration ----- #
library(dplyr)
library(purrr)
library(stringr)
library(tibble)
library(fixest)
library(duckdb)

source("src/utils/aggregation-tools.R") # for weighted_mean() function

# ----- STEP 1: Configure data from the database -----
con <- dbConnect(duckdb::duckdb(), "data/db/ipums.duckdb")
ipums_db <- tbl(con, "ipums_processed")

ipums_2000_db <- ipums_db |> filter(YEAR == 2000) |> filter(GQ %in% c(0,1,2))
ipums_2019_db <- ipums_db |> filter(YEAR == 2000) |> filter(GQ %in% c(0,1,2))


# ----- STEP 2: Define functions to tidy up the regression results and weighted means ----- 

tidy_regression <- function(model, varnames = varnames_dict) {
  coefs <- as_tibble(model$coeftable, rownames = "coef") |>
    select(coef, Estimate) |>
    mutate(
      variable = map_chr(coef, ~ varnames[str_detect(.x, fixed(varnames))][1]),
      value = if_else(!is.na(variable), str_remove(coef, fixed(variable)), coef)
    )
  
  # Try to get fixed effects — return empty tibble if they don’t exist
  fes <- tryCatch({
    fixef(model)[["cpuma"]] |>
      enframe(name = "value", value = "Estimate") |>
      mutate(variable = "cpuma", coef = paste0(variable, value))
  }, error = function(e) {
    tibble(coef = character(), Estimate = numeric(), variable = character(), value = character())
  })
  
  # Combine
  out <- bind_rows(coefs, fes)
  
  # Add NA cols for all varnames
  out[varnames] <- NA_character_
  
  # Fill correct column per row
  for (i in seq_len(nrow(out))) {
    var <- out$variable[i]
    if (var %in% varnames) {
      out[[i, var]] <- out$value[i]
    }
  }
  
  return(out)
}

tidy_weighted_means <- function(varnames_dict, data, value_column, weight_column) {
  map_dfr(varnames_dict, function(varname) {
    # Compute weighted mean for this variable
    wm <- weighted_mean(
      data = data,
      value_column = value_column,
      weight_column = weight_column,
      group_by_columns = varname
    ) |> 
      collect() |> 
      rename(value = !!sym(varname)) |> 
      mutate(
        variable = varname,
        coef = paste0(variable, value),
        value = as.character(value)
      ) |> 
      select(coef, variable, value, everything())
    
    return(wm)
  })
}

# ----- STEP 3: Combine the regression results and weighted means ---- #

# Load regression results generated by kob/scripts/linear-regressions.R
load("kob/throughput/regression_models.RData")

# Calculate weighted means for each regression functional form
reg00_weighted_means <- tidy_weighted_means(
  reg00$varnames_dict, # It could from the 2000 or 2019 regression, doesn't matter which
  data = ipums_2000_db,
  value_column = "NUMPREC",
  weight_column = "PERWT"
)

reg01_weighted_means <- tidy_weighted_means(
  reg01_2000$varnames_dict,
  data = ipums_2000_db
)
